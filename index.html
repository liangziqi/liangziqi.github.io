<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">




    <meta name="keywords" content=""/>



    <meta name="description" content=""/>


<meta name="Robots" content="all">


    <title>Maomaofat&#39;s Blog</title>


<link rel="icon" href="/images/favicon.ico">

<link rel="stylesheet" href="/css/font-awesome.min.css">


<link rel="stylesheet" href="/css/atom-one-dark.css">


<link rel="stylesheet" href="/css/style.css">


<script src="/js/highlight.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"></head>
<body>
    <div class="main-container">
        <header class="header">
    <div class="global-width">
        <nav class="nav-box">
            
                <a class="nav-item" href="/"
                
                >首页</a>
            
                <a class="nav-item" href="/about"
                
                >关于</a>
            
        </nav>
    </div>
</header>

        <section class="content global-width">
            <div class="main">
                
    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/07/codeforces-pratice/">codeforces-pratice 712(Div.1)</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-07</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/07/codeforces-pratice/">
                    <p>
                        
                            A. Balance the Bits给定一个偶数长度的01串s,问是否可以构造两个括弧序列,满足:

如果s[i]为1,那么两个串第i位相同


如果s[i]为0,那么两个串第i位不同

首先串s中0的个数和1的个数一定得是偶数个.
然后对于两个串相同的位置,尽量把左括号放在前面,右括号放在后面,这样一定是最优的方案.
#include&lt;bits/stdc++.h&gt;
using namespace std;
char s[200005];
char t[200005],q[2000005];
int n,T;
int main() &#123;
    scanf(&quot;%d&quot;,&amp;T);
    while(T--) &#123;
        scanf(&quot;%d&quot;,&amp;n); scanf(&quot;%s&quot;,s+1);
        int sum=0;
        for(int i=1;i&lt;=n;i++) if(s[i]==&#39;0&#39;) sum++;
        if(sum&amp;1) &#123;puts(&quot;NO&quot;);continue;&#125;
        sum = (n-sum)/2;
        int sum1 = 0, sum2 = 0;
        for(int i=1;i&lt;=n;i++) &#123;
            if(s[i]==&#39;1&#39;) &#123;
                if(sum&gt;0) t[i]=q[i]=&#39;(&#39;,sum1++,sum2++;
                else t[i]=q[i]=&#39;)&#39;,sum1--,sum2--;
                sum--;
            &#125;else &#123;
                if(sum1 &gt; sum2) sum1--, sum2++, t[i] = &#39;)&#39;, q[i] = &#39;(&#39;;
                else sum2--, sum1++, t[i] = &#39;(&#39;, q[i] = &#39;)&#39;;
            &#125;
            if(sum1&lt;0||sum2&lt;0) break;
        &#125;
    //    cout &lt;&lt; sum1 &lt;&lt;&quot; &quot;&lt;&lt;sum2&lt;&lt;endl;
        if(sum1 == 0 &amp;&amp; sum2 == 0) &#123;
            puts(&quot;YES&quot;);
            for(int i=1;i&lt;=n;i++) printf(&quot;%c&quot;,t[i]);
            puts(&quot;&quot;);
            for(int i=1;i&lt;=n;i++) printf(&quot;%c&quot;,q[i]);
            puts(&quot;&quot;);
        &#125;else puts(&quot;NO&quot;);
    &#125;
    return 0;
&#125;

B. 3-Coloring交互题,三种颜色,n*n的方阵,每次输入1种颜色,此时必须使用其他三种颜色给方阵染色,要求两个相邻的格子颜色不同,求染色的方案.
想了一会儿,发现其实很简单.
如果只有两种颜色,那答案只能是:

那么可以把第三种颜色作为辅助,如果输入不为1,我们就用1填充红色区域,反之用2填充橙色区域,假设红色区域被填充满了,就用剩下的2,3填充剩余橙色的区域.
#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
int main() &#123;
    cin &gt;&gt; n;
    int x = 1, y = 1;// 1 3
    int X = 1, Y = 2;// 2 3
    int m = n*n, flag = 0;
    while(m--) &#123;
        int T; scanf(&quot;%d&quot;,&amp;T);
        if (!flag) &#123;
            if(T != 1) &#123;
                printf(&quot;1 %d %d\n&quot;,x, y);
                y += 2;
                if (y &gt; n) x++,y=(y&amp;1)?2:1;
                if (x &gt; n) flag = 1;
            &#125;else &#123;
                printf(&quot;2 %d %d\n&quot;,X, Y);
                Y += 2;
                if (Y &gt; n) X++,Y=(Y&amp;1)?2:1;
                if (X &gt; n) flag = 1;
            &#125;
        &#125;else &#123;
            if (x &gt; n) &#123;
                if(T == 2) printf(&quot;3 %d %d\n&quot;,X, Y);
                else printf(&quot;2 %d %d\n&quot;,X, Y);
                Y += 2;
                if (Y &gt; n) X++,Y=(Y&amp;1)?2:1;
            &#125;else&#123;
                if(T == 1) printf(&quot;3 %d %d\n&quot;,x, y);
                else printf(&quot;1 %d %d\n&quot;,x, y);
                y += 2;
                if (y &gt; n) x++,y=(y&amp;1)?2:1;
            &#125;
        &#125;
        fflush(stdout);
    &#125;
    return 0;
&#125;


    
    
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    

### C. Travelling Salesman Problem
给定n个城市的$b_i$和$c_i$,从第i个城市出发到第j个城市的花费是$max(c_i,a_j-a_i)$
求从第一个城市出发,经历过每一个城市后,再返回到第一个城市的最小代价.

想了很久还是不会做,看题解.
发现对于最终答案,每一个$c_i$都会用到.
那我们把花费改成$c_i+max(0,a_j-a_i-c_i)$
我们先把城市a从小到大排列,发现答案是从$a_1$到$a_n$的最小代价,其余的点直接往前跑,代价为0;
我们为任何i&gt;1的城市计算到达城市i的最小可能成本(从左到右),剩下的点从右往左探索是免费的.答案为:$$\sum^n_{i=2,i&gt;j}max(0,a_i-max(a_j+c_j))+\sum^n_{i=1}c_i$$
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 100005;
const long long inf = 1e15;
typedef long long ll;
int n;
long long ans;
struct data&#123;
    int x, c;
    bool operator &lt;(const data &amp;a)const &#123;
        return x&lt;a.x;
    &#125;
&#125;a[N];
int main() &#123;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;i++) 
        scanf(&quot;%d%d&quot;,&amp;a[i].x, &amp;a[i].c), ans += a[i].c;
    sort(a+1,a+1+n);
    long long mx = a[1].c+a[1].x;
    for(int i=2;i&lt;=n;i++) &#123;
        ans += max(0ll, 1ll*a[i].x-mx);
        mx = max(mx, 1ll*a[i].x+a[i].c);
    &#125;
    printf(&quot;%lld\n&quot;,ans);
//    system(&quot;pause&quot;);
    return 0;
&#125;


Update
F. Flip the Cards题意:有n张卡片,正反面都有数字,大小为1~2n,且每个数字都只会出现一次,设$a_i$表示第i张卡片正面的数字,$b_i$表示第i张卡片背面的数字,可以翻卡来交换正反面,问至少进行几次翻卡,任意选择卡片的位置,满足$$a_1 &lt; a_2 &lt; … &lt; a_{n-1} &lt; a_n$$$$b_1 &gt; b_2 &gt; … &gt; b_{n-1} &gt; b_n$$

性质1:如果卡片数字正面为1n的背面数字也是1n,那么这种情况肯定无法满足条件,因为肯定也有一张卡片正面和反面的数字都是n+1~2n.这两张卡片无论如何翻都无法满足条件.


性质2:用$f(x), x \in [1,n]$表示一个面数字为x的卡片另一面的数字,可以发现想要满足条件那么$f(x)$可以分成两个递减序列.

那么问题就变成把$f(x)$分成两个递减序列至少需要翻面几次.
考虑如何贪心,可以把这些数放入两个满足递减的集合,对与特定的$i$,满足$$\min\limits_{j\le i} f(j)&gt;\max\limits_{j&gt;i}f(j)$$那么可以把i和i+1设置一个断点,这样可以把序列分成若干个段.
每一个段互不影响,并且每一个段只有两种分配方式,就可以贪心了.
复杂度$O(n)$
#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 200005;
int n, a[N], b[N], mn[N], mx[N], dd[N], tot, ans;
int A[N], B[N];
int main() &#123;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 1; i &lt;= n; i++) &#123;
        int x, y; scanf(&quot;%d%d&quot;,&amp;x, &amp;y);
        if (x &lt;= n) a[x] = y;
        if (y &lt;= n) a[y] = x, b[y] = 1;
    &#125;
    for(int i = 1; i &lt;= n; i++) 
        if(a[i] &lt;= n) &#123;
            puts(&quot;-1&quot;);
            return 0;
        &#125;
    mn[1] = a[1];
    for(int i = 2; i &lt;= n; i++) mn[i] = min(mn[i-1], a[i]);
    mx[n] = a[n];
    for(int i = n-1; i; i--) mx[i] = max(mx[i+1], a[i]);
    for(int i = 1; i &lt; n; i++) 
        if (mn[i] &gt; mx[i+1]) dd[++tot] = i;
    dd[++tot] = n;
    for(int k = 1; k &lt;= tot; k++) &#123;
        int sum = 0, AT = 0, BT = 0;
        for (int i = dd[k-1]+1; i &lt;= dd[k]; i++) &#123;
            if (!AT || AT &amp;&amp; A[AT] &gt; a[i]) A[++AT] = a[i], sum += b[i];
            else if(!BT || BT &amp;&amp; B[BT] &gt; a[i]) B[++BT] = a[i], sum += b[i]^1;
            else return puts(&quot;-1&quot;)&amp;0;
        &#125;
        ans += min(sum, dd[k]-dd[k-1]-sum);
    &#125;
    printf(&quot;%d\n&quot;,ans);
//    system(&quot;pause&quot;);
    return 0;
&#125;


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/Codeforces/" rel="tag">Codeforces</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/06/taiji/">taiji</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-06</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/06/taiji/">
                    <p>
                        
                            我日,还要打太极拳.
太极好像要考试
感觉得好好应酬,不然考试就GG了

    


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/%E6%97%A5%E5%B8%B8/" rel="tag">日常</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/04/EAapex/">EAapex</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-04</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/04/EAapex/">
                    <p>
                        
                            同学叫我去玩apex,因为三缺一
电脑上尝试注册EA的账号,人机验证他给我算色子点数的题目,竟然还让我算10次

让我算数也就算了,竟然错一个就要重做!!?


让我重做也就算了,竟然说我超出时间???


好家伙,敢情我注册个账号都要当个最强大脑才给我过.
感觉以后可以把这个给swwind这个坏东西去做
Update:同学说要用手机浏览器注册账号,我试了一下,还是要人机验证
只不过这次验证是找Penguins,还只有两张图
我:???

敢情你歧视电脑?
晚上就跟室友开黑(我很菜的

。。。他竟然不上当

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/Game/" rel="tag">Game</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/04/improper-integral/">无穷积分</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-04</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/04/improper-integral/">
                    <p>
                        
                            无穷限反常积分定义
    
    
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    

设函数f定义在无穷区间[a,$+\infty$)上，且在任何有限区间[a,u]上可积。如果存在极限
$$\lim_{u\rightarrow+\infty}\int ^u_a f(x)dx =J$$
则称极限J为函数在[a,$+\infty$)上的无穷限反常积分

并称$\int ^{+\infty}_a f(x)dx$ 收敛。如果极限J不存在，则称其发散。
瑕积分定义设函数f在(a,b]上，在点a的任一右邻域上无上界但在任何闭区间[u,b]$\subset$(a,b]上有界且可积，如果存在极限:$$\lim_{u\rightarrow{a^+}}\int ^b_u f(x)dx = J$$
则极限J为无界函数的反常积分，并称反常积分$\int ^b_a f(x)dx$收敛，反之则发散
由于被积函数在点a近旁是无界的，这是点a称为f的瑕点，而无界函数反常积分$\int ^b_a f(x)dx$又称为瑕积分。
无穷积分的性质定理一无穷积分$\int ^{+\infty}_a f(x)dx$ 收敛的充分必要条件是:
对于${\forall}\epsilon &gt; 0$,$\exists G&gt;0$,只要M,N&gt;G,便有$$|\int ^M_a f(x)dx - \int ^N_a f(x)dx| = |\int ^M_N f(x)dx| &lt; \epsilon$$
性质一$\int ^{+\infty}_a f1(x)dx$收敛，$\int ^{+\infty}_a g(x)dx$收敛,那么$\int ^{+\infty}_a [k1f(x)+k2g(x)]dx$也收敛,且:$\int ^{+\infty}_a [k1f(x)+k2g(x)]dx$=$\int ^{+\infty}_a f1(x)dx$ + $\int ^{+\infty}_a g(x)dx$
性质二$\int ^{+\infty}_a f(x)dx$收敛的另一个充要条件:
$\forall \epsilon &gt;0$,$\exists G \geq a$，当u &gt; G时，总有$|\int ^{+\infty}_u f(x)dx| &lt; \epsilon$
性质三若f在任何有限区间[a,u]上可积，且有$\int ^{+\infty}_a |f(x)|dx$收敛，则$\int ^{+\infty}_a f(x)dx$也必收敛，并有:$$|\int ^{+\infty}_a f(x)dx| \leq \int ^{+\infty}_a |f(x)|dx$$
$\int ^{+\infty}_a |f(x)|dx$收敛时收敛时，称$\int ^{+\infty}_a |f(x)|dx$为绝对收敛。绝对收敛的无穷积分，自身一定收敛，逆命题不成立。
收敛而不绝对收敛者称为条件收敛
非负函数无穷积分的敛散判别法定理(比较原则)
设定义在[a,$+/infty$)上的两个非负函数f和g都在任何有限区间[a,u]上可积,且满足$$f(x) \leq g(x), x \in [a,+\infty)$$

则当$\int ^{+\infty}_a g(x)dx$收敛时,$\int ^{+\infty}_a f(x)dx$必收敛($\int ^{+\infty}_a f(x)dx$发散时,$\int ^{+\infty}_a g(x)dx$必发散)
推论1若f和g都在任何有限区间[a,u]上可积,当$x \in [a,+\infty)$时,f(x)&gt;=0,g(x)&gt;0,且$\lim_{x\rightarrow+\infty}{\frac{f(x)}{g(x)}}=c$,则有:

(i) 当 0 &lt; c &lt; $+\infty$时,$\int ^{+\infty}_a f(x)dx$ 与$\int ^{+\infty}_a g(x)dx$ 同敛态


(ii)当 c = 0 时,由$\int ^{+\infty}_a g(x)dx$ 收敛可推知$\int ^{+\infty}_a f(x)dx$ 收敛


(iii) 当 c = $+\infty$ 时,由$\int ^{+\infty}_a g(x)dx$ 发散可推知$\int ^{+\infty}_a f(x)dx$ 也发散

如果选用$\int ^{+\infty}_1 \frac{dx}{x^p}$作为比较对象,则有以下两个推论(柯西判别法)
推论2设f定义于[a,$+\infty$)(a&gt;0),且在任何有限区间[a,u]上可积,则有

(i) 当 $0 \leq f(x) \leq \frac{1}{x^p}, x \in [a,+\infty)$,且p &gt; 1,$\int ^{+\infty}_a f(x)dx$ 收敛


(ii) 当 $f(x) \geq \frac {1}{x^p}, x \in [a,+\infty)$,p $\leq$ 1,$\int ^{+\infty}_a f(x)dx$ 发散

推论3设f是定义于[a,$+\infty$)上的非负函数,在任何有限区间[a,u]上可积,且$\lim_{x\rightarrow+\infty}x^p f(x) = \lambda$ 则有:

(i) $p &gt; 1,0 \leq \lambda &lt; +\infty$ 时,$\int^{+\infty}_a f(x)dx$ 收敛.


(ii) $p \leq 1, 0 &lt; \lambda \leq +\infty$ 时, $\int^{+\infty}_a f(x)dx$ 发散

一般无穷积分的敛散判别法狄利克雷判别法若 $F(u) = \int ^u_a f(x)dx$ 在[a,$+\infty$)上有界,g(x)在[a,$+\infty$)上当$x\rightarrow +\infty$时单调趋于0,则$\int^{+\infty}_a f(x)g(x)dx$ 收敛
证明:
设$|\int^u_a f(x)dx| \leq M, u \in [a,+\infty)$.
$\forall \epsilon &gt; 0, \exists G \geq a,x &gt; G$时,有$$|g(x)| &lt; \frac{\epsilon}{4M}$$g为单调函数,由第二中值定理推论:对于任何b&gt;a&gt;G,$\exists t \in [a,b]$ 使得$$\int^b_a f(x)g(x)dx = g(a)\int^t_a f(x)dx + g(b)\int^b_t f(x)dx$$于是$$|\int^b_a f(x)g(x)dx| = |g(a)||\int^t_a f(x)dx| + |g(b)||\int^b_t f(x)dx|$$$$|\int^b_a f(x)g(x)dx| \leq \frac{\epsilon}{4M}*4M = \epsilon$$证毕
阿贝尔(Abel)判别法(为什么不叫阿贝多)若$\int^{+\infty}_a f(x)dx$ 收敛,g(x)在[a,$+\infty$)上单调有界,则$\int^{+\infty}_af(x)g(x)dx$ 收敛
证明:设$J = \lim_{x\rightarrow +\infty}g(x)$
$$\int^{+\infty}_a f(x)g(x)dx = J\int^{+\infty}_a f(x)dx+\int^{+\infty}_a f(x)[g(x)-J]dx$$
右边第一项收敛,第二项可以用上述的狄利克雷判别法证明其收敛,所以$\int^{+\infty}_a f(x)g(x)dx$收敛
由于瑕积分的性质,敛散判别法基本于无穷积分相似,故不再赘述(其实是因为我懒

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/%E6%95%B0%E5%88%86/" rel="tag">数分</a>, <a class="tag-none-link" href="/tags/%E7%A7%AF%E5%88%86/" rel="tag">积分</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/03/Kunming-region/">昆明区域赛</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-03</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/03/Kunming-region/">
                    <p>
                        
                            这场800多个队打，我这么菜根本拿不了牌。
还有题目怎么这么鬼畜，纸质题面的某些题竟然和电脑的题面的序号对不上。
开局看了一会题，队长发现H题过了500多个人，发现是一道真签到题。
过了一会发现其他题都没什么思路，然后发现很多人A了L题，于是看L。

L的题意:给定一个排列，排列中逆序的两个位置连一条边，然后给这些位置染色，要求给球染色最少需要多少颜色，并给出一个正确的染色方式，n&lt;=1e5。

自己想了很久都想不出来L怎么做，感觉可以求mex，但这个复杂度感觉有问题(没问题就是我不会写)
队友想了好久，发现这可以答案是最长下降子序列的长度，那么染色的方式就是将当前点染成与当前数在最长下降子序列的位置。这样可以保证是正确的。
然后我去看k题。

K的题意:给定一个排列，每次可以选很多对位置进行交换，但每个位置每次只能被交换一次。比如（1，3，2，4），假如这次操作交换第1和第2个数，那么这次操作的其他交换中不能再出现第1和第2个数，也就是只能再交换第3个数和第4个数。然后求最少用几次操作。并求出每次操作的方式。

容易看出这玩意就是个置换环，但是怎么求答案呢？

    
    
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    

我一开始的想法是答案是$max(\lceil \log2(置换环的长度) \rceil)$

然后Wa了两个小时。
想了好久觉得代码没错，然后终于发现是答案有问题，我随手画了个图，然后发现对于每个置换环，答案要不是1，要不是2。
a[i]=i,那么第i个位置不参与交换。
环的元素有两个，那么直接交换，答案为1。
环的元素多于两个，那么交换方式就是下图。
 
所以答案只能是0，1，2。然后这个方式就是答案
要不是这个数据这么弱，怎么可能跳进坑
J题的计算几何，丢给队长做，然后队长没做出来。
成功打铁，回去睡觉。

                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/ACM/" rel="tag">ACM</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/04/02/post/">昆明热身赛</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-04-02</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/04/02/post/">
                    <p>
                        
                            
    
    
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    

今天打了热身赛，三道签到题。但我没做出来，过来一个星期没练就生疏了。

T1让你求在n个数中取k个能得到的最大和，经典sb题。
T2题意是n个数，第i次操作是让第i个数加上（n-1）*s，其他数减去s。
打的时候脑瘫了，让队友去写线段树，队友写炸了。大雾
容易看出第i次操作后，位置为[1,i]的数的值为原数+(n-i)*s。
位置为[i+1,n]的数的值为原数-i*s。
所以做前后缀min，对于每一次操作都能o(1)求最小值。
T3题意是有n个路灯位置为[1,n]，k个雕塑，告诉你k个雕塑的位置与价值，从i路灯移到j路灯的代价为|i-j|*s。问将雕塑按位置使价值从小到大排列的最小代价，k&lt;=n&lt;=5000。
比较水的动态规划，dp[i][j]表示在1-j的位置上保证前i个雕塑合法的最优解。
那么dp[i][j]=$\max(dp[i][j-1],dp[i-1][j-1]+\lvert i-j \rvert*s)$
所以热身赛都是水题感觉全场只有我没有AK


                        
                    </p>
                </a>
            </div>

            
                <div class="post-footer">
                    
                    
                        <i class="fa fa-tags"></i>
                        <a class="tag-none-link" href="/tags/ACM/" rel="tag">ACM</a>
                    
                </div>
            
        </article>
    

    
        <article class="box post post-item">
            <div class="post-title"><a href="/2021/03/31/hello-world/">杀鸟</a></div>
            <div class="post-meta">
                
                <i class="fa fa-calendar"></i> <time>2021-03-31</time>
                <span class="dotted">|</span>
                <i class="fa fa-user"></i> 
            </div>

            <div class="post-excerpt">
                <a href="/2021/03/31/hello-world/">
                    <p>
                        
                            杀鸟也太狠了
原神真好玩
                        
                    </p>
                </a>
            </div>

            
        </article>
    



            </div>
            <div class="aside">
    
        <div class="box widget">
    <div class="introduction">
        <p><img src="/images/avatar.jpg" alt="head-sculpture" /></p>
        <p class="name">
            Maomaocat
        </p>
        <p class="slogan">感觉挺好的.</p>
    </div>
</div>
    
        
<div class="box widget">
    <div class="title">最新</div>
    <ul class="item-box">
        
            
                <li><a href="/2021/04/07/codeforces-pratice/">codeforces-pratice 712(Div.1)</a></li>
            
        
            
                <li><a href="/2021/04/06/taiji/">taiji</a></li>
            
        
            
                <li><a href="/2021/04/04/EAapex/">EAapex</a></li>
            
        
            
                <li><a href="/2021/04/04/improper-integral/">无穷积分</a></li>
            
        
            
                <li><a href="/2021/04/03/Kunming-region/">昆明区域赛</a></li>
            
        
            
                <li><a href="/2021/04/02/post/">昆明热身赛</a></li>
            
        
            
                <li><a href="/2021/03/31/hello-world/">杀鸟</a></li>
            
        
    </ul>
</div>

    
        
    
        
  <div class="box widget">
    <div class="title">归档</div>
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">2021-04</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">2021-03</a><span class="archive-list-count">1</span></li></ul>
  </div>

    
        
    <div class="box widget">
        <div class="title">标签</div>
        <div class="item-box cloud-label">
            <a href="/tags/ACM/" style="font-size: 20px;">ACM</a> <a href="/tags/Codeforces/" style="font-size: 10px;">Codeforces</a> <a href="/tags/Game/" style="font-size: 10px;">Game</a> <a href="/tags/%E6%95%B0%E5%88%86/" style="font-size: 10px;">数分</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 10px;">日常</a> <a href="/tags/%E7%A7%AF%E5%88%86/" style="font-size: 10px;">积分</a>
        </div>
    </div>

    
        
    <div class="box widget">
      <div class="widget-title">友链</div>
        <div class="widget">
            <a href = "https://blog.swwind.me/">swwind</a>
        </div>
    </div>
  
    
</div>
        </section>
        <footer class="footer">
    <div class="global-width footer-box">
        <div class="copyright">
            <span>Copyright &copy; 2019</span>
            <span class="dotted">|</span>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span>
            <span class="dotted">|</span>
            <span>Theme by <a href="javascript:">Loren</a></span>
        </div>
    </div>
</footer>
    </div>

<script>
    hljs.initHighlightingOnLoad();
</script>
</body>
</html>